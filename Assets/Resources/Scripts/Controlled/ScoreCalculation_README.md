# 得分计算系统使用说明

## 概述
新的得分计算系统支持多种获胜组合类型，包括基础的横竖斜3连及以上，以及特殊的形状组合。

## 支持的获胜类型

### 1. 基础获胜组合
- **横向 (Horizontal)**: 同一行中3个或更多连续相同符号
- **纵向 (Vertical)**: 同一列中3个或更多连续相同符号  
- **斜向 (Diagonal)**: 对角线上3个或更多连续相同符号

**重要规则**: 连线必须是连续的，不能跳过中间的符号。例如：
- ✅ 正确：`1,1,1` (3连)
- ✅ 正确：`1,1,1,1` (4连)
- ❌ 错误：`1,2,1,2,1` (不能跳过2形成连线)

### 2. 特殊形状组合
- **方框 (Square)**: 2x2或更大的正方形区域，所有位置都是相同符号
- **V型 (VShape)**: V形或倒V形的3个位置都是相同符号
- **N型 (NShape)**: N形或倒N形的4个位置都是相同符号
- **全屏 (FullScreen)**: 整个4x5网格都是相同符号

## 符号定义
- `0`: 空位（不参与得分计算）
- `-1`: Wild符号（可以匹配任何符号）
- `1, 2, 3, ...`: 普通符号

## 使用方法

### 1. 基本使用
```csharp
// 获取SettlementeContro组件
SettlementeContro settlementController = FindObjectOfType<SettlementeContro>();

// 运行完整测试
settlementController.RunFullTest();

// 获取获胜组合
List<SettlementeContro.WinningCombination> wins = settlementController.CalculateWins();
```

### 2. 设置测试数据
```csharp
// 设置自定义网格数据
int[,] testGrid = {
    {1, 1, 1, 2, 0},
    {0, 2, 1, 2, 3},
    {3, 1, 2, 1, 3},
    {1, 2, 3, 3, 3}
};
settlementController.SetTestGrid(testGrid);
```

### 3. 获胜组合数据结构
```csharp
public class WinningCombination
{
    public int symbol;                    // 中奖符号
    public List<Vector2Int> positions;    // 中奖位置
    public int length;                    // 中奖长度
    public WinType winType;               // 中奖类型
}

public enum WinType
{
    Horizontal,  // 横向
    Vertical,    // 纵向
    Diagonal,    // 斜向
    Square,      // 方框
    VShape,      // V型
    NShape,      // N型
    FullScreen   // 全屏
}
```

## 特殊形状说明

### 方框形状
- 支持2x2、3x3等正方形区域
- 所有位置必须是相同符号
- 不能有空位

### V型形状
- 正V型：上-下-上 的3个位置
- 倒V型：下-上-下 的3个位置
- 所有位置必须是相同符号

### N型形状
- 正N型：左上-右上-左下-右下 的4个位置
- 倒N型：左下-右下-左上-右上 的4个位置
- 所有位置必须是相同符号

## 测试方法

### 1. 使用ScoreTest脚本
```csharp
// 在Unity中按T键运行测试
// 或者设置runTestOnStart = true自动运行
```

### 2. 手动测试
```csharp
// 创建测试网格
int[,] testGrid = CreateTestGrid();

// 设置网格并运行测试
settlementController.SetTestGrid(testGrid);
settlementController.RunFullTest();
```

## 测试用例

### 基础获胜测试
1. **横向3连**: 第一行有3个连续的符号1
2. **纵向3连**: 第一列有3个连续的符号1

### 特殊形状测试
3. **方框形状**: 左上角2x2区域都是符号1
4. **V型形状**: 形成V形的3个位置都是符号1
5. **N型形状**: 形成N形的4个位置都是符号1
6. **全屏**: 整个网格都是符号1

### 边界情况测试
7. **Wild符号**: 包含-1符号的组合
8. **空位处理**: 包含0空位的网格
9. **最小获胜**: 只有3连的组合

## 输出示例
```
=== 运行完整得分计算测试 ===
--- 当前网格数据 ---
行0: 1 1 1 2 0
行1: 0 2 1 2 3
行2: 3 1 2 1 3
行3: 1 2 3 3 3

===== 中奖结果 =====
--- Horizontal 类型获胜组合 ---
符号 1 的3连 (Horizontal): (0,0) (0,1) (0,2)
符号 3 的3连 (Horizontal): (3,2) (3,3) (3,4)

--- Vertical 类型获胜组合 ---
符号 1 的3连 (Vertical): (0,0) (1,2) (2,1)

总计获胜组合数: 3
```

## 注意事项

1. **最小获胜条件**: 所有获胜组合必须至少包含3个位置
2. **Wild符号**: -1可以匹配任何符号，但会被实际符号替换
3. **空位处理**: 0空位不参与任何获胜组合计算
4. **重复检测**: 系统会检测所有可能的获胜组合，包括重叠的组合
5. **边界检查**: 所有位置都会进行边界检查，确保不会越界
6. **连续连线规则**: 连线必须是连续的，不能跳过中间的符号

## 修复的问题

### 连线连续性修复
**问题描述**: 之前的版本允许跳过中间符号形成连线，例如 `1,2,1,2,1` 会被错误地识别为符号1的5连。

**修复方案**: 
- 重新实现了连线检测算法
- 确保所有连线都是连续的
- 添加了严格的连续性检查

**测试验证**: 
- 测试用例11专门验证连续连线规则
- 确保 `1,2,1,2,1` 不会产生任何连线
- 确保 `1,1,2,1,1` 只产生两个3连，而不是一个5连

## 性能优化

- 使用字典按类型分组结果，便于快速查找
- 边界检查避免数组越界
- 早期退出机制，遇到不匹配立即停止检查

## 扩展建议

1. 添加更多特殊形状（如L型、T型等）
2. 支持不同符号的权重系统
3. 添加连击奖励机制
4. 支持动态网格大小
5. 添加动画效果支持 